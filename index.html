<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <h2>Enjoy the new Way of studying algorithms</h2>
        <h1>Algorithm Visualizer</h1>
        <h3>Choose from below algorithms to get started</h3>
    </header>
    <section>
        <div class="algo-box" id="ls">
            <h1>LINEAR SEARCH</h1>
            <div class="desc">
                Linear search is a very simple search algorithm. In this type of search, a sequential search is made
                over all items one by one. Every item is checked and if a match is found then that particular item is
                returned, otherwise the search continues till the end of the data collection.
            </div>
            <button class="btn"><a href="./algorithms/linearSearch.html" target="_blank">LINEAR SEARCH</a></button>

        </div>
        <div class="algo-box" id="binary-search">
            <h1>BINARY SEARCH</h1>
            <div class="desc">
                Binary Search: Search a sorted array by repeatedly dividing the search interval in half. Begin with an
                interval covering the whole array. If the value of the search key is less than the item in the middle of
                the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly
                check until the value is found or the interval is empty.
            </div>
            <button class="btn bsearch"><a href="./algorithms/binarySearch.html" target="_blank">BINARY
                    SEARCH</a></button>
        </div>
        <div class="algo-box" id="bs">
            <h1>BUBBLE SORT</h1>
            <div class="desc">
                Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps
                through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass
                through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is
                named for the way smaller or larger elements "bubble" to the top of the list.
            </div>
            <button class="btn bsort"><a href="./algorithms/bubbleSort.html" target="_blank">BUBBLE SORT</a></button>

        </div>
        <div class="algo-box" id="ss">
            <h1>SELECTION SORT</h1>
            <div class="desc">
                Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based
                algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted
                part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.The
                smallest element is selected from the unsorted array and swapped with the leftmost element, and that
                element becomes a part of the sorted array. This process continues moving unsorted array boundary by one
                element to the right.
            </div>
            <button class="btn ssort"><a href="./algorithms/selectionSort.html" target="_blank">SELECTION
                    SORT</a></button>

        </div>
        <div class="algo-box" id="is">
            <h1>INSERTION SORT</h1>
            <div class="desc">
                This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always
                sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be
                'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted
                there. Hence the name, insertion sort. The array is searched sequentially and unsorted items are moved
                and inserted into the sorted sub-list
                (in the same array)
            </div>
            <button class="btn isort"><a href="./algorithms/insertionSort.html" target="_blank">INSERTION
                    SORT</a></button>
        </div>
        <div class="algo-box" id="ms">
            <h1>MERGE SORT</h1>
            <div class="desc">
                Like QuickSort, Merge Sort is a Divide and Conquer algorithm. It divides the input array into two
                halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is
                used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and
                arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.
            </div>
            <button class="btn msort"><a href="./algorithms/mergeSort.html" target="_blank">MERGE SORT</a></button>
        </div>
        <div class="algo-box" id="ps">
            <h1>QUICK SORT</h1>
            <div class="desc">
                Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into
                smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the
                specified value, say pivot, based on which the partition is made and another array holds values greater
                than the pivot value. Quicksort partitions an array and then calls itself recursively twice to sort the
                two resulting
                subarrays. This algorithm is quite efficient for large-sized data sets
            </div>
            <button class="btn psort"><a href="./algorithms/partitionSort.html" target="_blank">QUICK SORT</a></button>
        </div>
        <div class="algo-box">
            <h1>BREADTH FIRST SEARCH</h1>
            <div class="desc">
                Breadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies
                a given property. It starts at the tree root and explores all nodes at the present depth prior to moving
                on to the nodes at the next depth level. Extra memory, usually a queue, is needed to keep track of the
                child nodes that were encountered but not yet explored.Click on Create Blocked Cell and move mouse to
                create blocked cell which is
                represented by black color. Coral color denoted sorce cell and pink color denotes destination cell
                .After all this click on submit to visualize.
            </div>
            <button class="btn sh-path-find"><a href="./algorithms/bfs.html" target="_blank">VISUALIZE</a></button>
        </div>
        <div class="algo-box">
            <h1>DEPTH FIRST SEARCH</h1>
            <div class="desc">
                Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The
                algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a
                graph) and explores as far as possible along each branch before backtracking.Click on Create Blocked
                Cell and move mouse to create blocked cell which is
                represented by black color. Coral color denoted sorce cell and pink color denotes destination cell
                .After all this click on submit to visualize.
            </div>
            <button class="btn sh-path-find"><a href="./algorithms/dfs.html" target="_blank">VISUALIZE</a></button>
        </div>
        <div class="algo-box" id="sh-path">
            <h1>SHORTEST PATH FINDING</h1>
            <div class="desc">
                Shortest path in grid theory
                In graph theory, the shortest path problem is the problem of finding a path between two vertices (or
                nodes) in a graph. Click on Create Blocked Cell and move mouse to create blocked cell which is
                represented by black color. Coral color denoted sorce cell and pink color denotes destination cell
                .After all this click on submit to visualize.
            </div>
            <button class="btn sh-path-find"><a href="./algorithms/shortestPath.html" target="_blank">FIND
                    PATH</a></button>
        </div>

    </section>

</body>

</html>
